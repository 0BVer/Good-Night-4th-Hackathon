# Good-Night-4th-Hackathon
공연 좌석 예매 시스템 풀스택 구현

## 안내사항

- 본 레포지토리를 **fork**하여 과제를 수행하고, 완료시 PR을 보냅니다.
- 과제의 소스코드는 본인의 GitHub 레포지토리에 **Public**으로 올려주세요.
- 진행 간 문의사항은 이 레포지토리의 Issue로 등록해주세요.
- 구현 내용은 README.md 하단에 이어서 작성해 주세요.

## 과제 목표

공연 좌석 예매 시스템 구현

### 기술 스택

- Backend: 자유 선택 (Spring Boot, Node.js, Django, FastAPI 등)
- Frontend: 자유 선택 (React, Vue, Svelte, Vanilla JS 등)
- Database: 자유 선택
- 선택한 기술 스택에 대한 이유를 README에 간단히 설명해주세요

### 평가 항목

- 문제 해결 접근 방식에서 기술적 의사결정
- 구현 완성도와 문서화 수준

## 요구사항

### 최소 요구사항
> 아래 목표들을 달성하기 위한 구현 방법은 자유롭게 선택하세요.

1. **좌석 현황 표시**
    - 3x3 격자 형태로 총 9개의 좌석 표시
    - 각 좌석의 예약 가능/불가능 상태를 시각적으로 구분
2. **좌석 예약 기능**
    - 사용자가 빈 좌석을 클릭하여 선택
    - 페이지를 이동하여 예약자 정보 입력
    - 정보 입력 완료 후 예약 확정 시도
        - 99% 확률로 예약 성공 처리
        - 1% 확률로 의도적 실패 처리
    - 예약 성공/실패에 대한 명확한 피드백 제공
3. **API 엔드포인트**
    - 좌석 목록 조회 API
    - 좌석 예약 요청 API
    - HTTP 통신을 통한 데이터 교환
4. **코드 품질 보장**
    - 테스트 코드
    - 타입 체크
    - 린팅

### 기본 요구사항

> 아래 목표들을 달성하기 위한 구현 방법은 자유롭게 선택하세요.

> 각 목표를 어떻게 해결했는지 README에 설명해주세요.

1. **사용자 경험 개선**
    - **목표**: 사용자가 서비스를 이용할 때 발생할 수 있는 불편함 최소화
    - **예시**
        - 직관적인 UI
        - 네트워크 지연이 발생했을 때 편의성
        - 예약이 실패했을 때 편의성
        - 모바일에서 접속했을 때 편의성
2. **안정적인 서비스 운영**
    - **목표**: 예상치 못한 상황에서도 서비스가 안정적으로 동작
    - **예시**
        - 잘못된 요청이 들어왔을 때
        - 존재하지 않는 좌석을 예약하려 할 때
        - 서버 에러가 발생했을 때
        - 데이터 정합성 보장

### 심화 요구사항

> 아래 목표들을 달성하기 윈한 구현 방법은 자유롭게 선택하세요.

> 각 목표를 달성했음을 검증할 방법을 마련하세요.

> 시도한 방법이 어떤 방식으로 문제를 해결했으며 보유한 한계점에 대해 상세히 README에 설명해주세요.


1. **동시성 제어**
    - **상황**: 여러 사용자가 동시에 같은 좌석을 예약하려고 시도하는 경우
    - **목표**: 한 좌석에 대해 단 한 명만 예약에 성공하도록 보장
2. **실시간 좌석 상태 동기화**
    - 상황: UI에서 사용자들이 이미 선택된 좌석을 선택하게 되는 경우
    - 목표: 실시간 좌석 예약 상태를 확인할 수 있도록 실시간 동기화 제공
3. **선택한 좌석에 대한 우선순위 제공**
    - 상황 : 좌석 선택 후 예약자 정보를 입력하는 동안 다른 사용자가 좌석을 예약하게 되는 경우
    - 목표: 동일 좌석에 대해 먼저 선택을 한 사용자에게 예약 우선순위 제공

## 참고사항

### 진행 방식

- 최소 요구사항을 먼저 완성한 후 기본 기능을 구현해주세요
- 심화 요구사항은 구현에 실패해도 고민한 해결 방법이 있으면 작성해주세요.

### 필수 제출 항목

- **README.md**: 다음 내용을 반드시 포함
    - 프로젝트 실행 방법 (상세하게)
    - 기술 스택 선택 이유
    - 구현한 요구사항 체크리스트
    - 각 요구사항별 해결 방법 설명

### 선택 제출 항목

- 아키텍처 다이어그램
- 시연 영상 또는 GIF

---

<!-- 구현 내용 작성 -->

## 프로젝트 실행 방법

본 프로젝트는 Docker Compose를 사용하여 간편하게 실행할 수 있습니다.

1.  **Docker 설치**: 시스템에 [Docker](https://www.docker.com/get-started)가 설치되어 있어야 합니다.
2.  **레포지토리 클론**:
    ```bash
    git clone <your-fork-url>
    cd Good-Night-4th-Hackathon
    ```
3.  **Docker Compose 실행**:
    ```bash
    docker-compose up --build
    ```
4.  **애플리케이션 접속**:
    -   웹 브라우저를 열고 `http://localhost` 로 접속합니다. (프론트엔드 Nginx 서버는 80번 포트를 사용합니다.)
    -   백엔드 API는 `http://localhost:8080` 에서 직접 접근할 수 있습니다.

## 기술 스택 선택 이유

-   **Backend (Spring Boot + JPA)**
    -   **Spring Boot**: 강력한 의존성 주입(DI), 방대한 레퍼런스, 안정적인 생태계를 기반으로 빠르고 견고한 서버를 구축할 수 있습니다. Spring Initializr를 통해 프로젝트를 신속하게 설정할 수 있는 장점이 있습니다.
    -   **Spring Data JPA**: SQL을 직접 작성하지 않고도 객체 지향적으로 데이터베이스를 조작할 수 있어 생산성이 높고, 유지보수가 용이합니다.

-   **Frontend (React + Vite)**
    -   **React**: 컴포넌트 기반 아키텍처를 통해 재사용 가능하고 논리적인 UI 구조를 만들 수 있습니다. 방대한 커뮤니티와 자료 덕분에 문제 해결이 용이합니다.
    -   **Vite**: 매우 빠른 빌드 속도와 Hot Module Replacement(HMR)를 제공하여 개발 경험을 크게 향상시킵니다.
    -   **TypeScript**: 정적 타이핑을 통해 런타임 에러를 사전에 방지하고, 코드의 안정성과 가독성을 높입니다.

-   **Database (SQLite)**
    -   별도의 서버 설정 없이 파일 기반으로 동작하여 가볍고 빠르게 로컬 환경을 구축할 수 있습니다. 소규모 프로젝트나 프로토타이핑에 적합하여 본 과제에 채택했습니다.

-   **Containerization (Docker)**
    -   Docker를 통해 개발 환경과 배포 환경을 일치시켜 "내 컴퓨터에서는 됐는데..."와 같은 문제를 원천적으로 차단합니다.
    -   `docker-compose`를 사용하면 프론트엔드, 백엔드, 데이터베이스 볼륨을 한 번의 명령으로 관리할 수 있어 테스트와 배포가 매우 편리합니다.

## 구현한 요구사항 체크리스트

-   [x] **최소 요구사항**
    -   [x] 좌석 현황 표시 (3x3 격자)
    -   [x] 좌석 예약 기능 (성공/실패 피드백 포함)
    -   [x] API 엔드포인트 (좌석 목록 조회, 좌석 예약)
    -   [x] 코드 품질 보장 (단위/통합 테스트, 타입 체크, 린팅)
-   [x] **기본 요구사항**
    -   [x] 사용자 경험 개선 (직관적 UI, 로딩/실패 처리, 반응형)
    -   [x] 안정적인 서비스 운영 (예외 처리, 데이터 정합성)
-   [ ] **심화 요구사항** (미구현)
    -   [ ] 동시성 제어
    -   [ ] 실시간 좌석 상태 동기화
    -   [ ] 선택한 좌석에 대한 우선순위 제공

## 각 요구사항별 해결 방법 설명

### 최소 요구사항

1.  **좌석 현황 표시**:
    -   React `useState`와 `useEffect`를 사용하여 백엔드 API(`GET /api/seats`)에서 좌석 목록을 비동기적으로 받아옵니다.
    -   받아온 좌석 데이터를 3x3 `grid` CSS 레이아웃을 가진 `SeatGrid` 컴포넌트에 렌더링합니다.
    -   각 좌석의 `isReserved` 상태에 따라 조건부 CSS 클래스(`available`, `reserved`)를 적용하여 시각적으로 구분했습니다.

2.  **좌석 예약 기능**:
    -   사용자가 예약 가능한 좌석을 클릭하면, 선택된 좌석 정보를 `App` 컴포넌트의 상태로 저장하고 `ReservationForm` 컴포넌트를 렌더링합니다.
    -   예약자 이름 입력 후 '예약 확정' 버튼을 누르면 `POST /api/seats/{id}/reserve` API를 호출합니다.
    -   백엔드 `SeatService`에서는 `Math.random() < 0.01` 조건을 통해 1% 확률로 의도적인 예약 실패를 시뮬레이션하고, `ReservationFailedException`을 발생시킵니다.
    -   API 호출 결과에 따라 `alert()`을 통해 성공 메시지를, 예약 실패 시에는 Form 내에 에러 메시지를 명확하게 표시하여 사용자에게 피드백을 제공합니다.

3.  **API 엔드포인트**:
    -   `SeatController`에 두 개의 엔드포인트를 구현했습니다.
        -   `GET /api/seats`: 모든 좌석의 현재 상태를 JSON 배열로 반환합니다.
        -   `POST /api/seats/{id}/reserve`: 예약자 정보를 받아 좌석을 예약 처리하고, 업데이트된 좌석 정보를 반환합니다.

4.  **코드 품질 보장**:
    -   **테스트**: JUnit5와 Mockito를 사용하여 `SeatService`에 대한 단위 테스트와 `SeatController`에 대한 통합 테스트를 작성하여 백엔드 로직의 신뢰성을 확보했습니다.
    -   **타입 체크**: 프론트엔드 프로젝트 전체에 TypeScript를 적용하여 데이터 모델과 컴포넌트 props의 타입을 명시하고, 타입 안정성을 강화했습니다.
    -   **린팅**: Vite가 기본 제공하는 ESLint 설정을 통해 일관된 코드 스타일을 유지했습니다.

### 기본 요구사항

1.  **사용자 경험 개선**:
    -   **직관적인 UI**: 좌석 선택 -> 정보 입력 -> 예약 확정으로 이어지는 단순하고 명확한 워크플로우를 채택했습니다.
    -   **네트워크 지연**: `axios`로 API를 호출하는 동안 'Loading...', 'Reserving...'과 같은 메시지를 표시하여 사용자가 시스템이 동작 중임을 인지할 수 있도록 했습니다.
    -   **예약 실패**: 예약 실패 시 `alert` 대신 Form 내에 구체적인 에러 메시지(예: "이미 예약된 좌석입니다")를 표시하여 사용자가 상황을 명확히 파악하고 다음 행동을 결정할 수 있도록 도왔습니다.
    -   **모바일**: CSS Grid와 Flexbox를 기반으로 한 유연한 레이아웃을 설계하여 추가적인 미디어 쿼리 없이도 모바일 화면에서 기본적인 사용성을 제공합니다.

2.  **안정적인 서비스 운영**:
    -   **예외 처리**: Spring의 `@ControllerAdvice`와 `@ExceptionHandler`를 사용하여 서비스 전반의 예외를 일관되게 처리합니다. 존재하지 않는 좌석(`404 Not Found`), 이미 예약된 좌석(`409 Conflict`), 서버 내부 오류(`500 Internal Server Error`) 등 상황에 맞는 HTTP 상태 코드와 명확한 에러 메시지를 반환하여 클라이언트가 에러 상황에 대처할 수 있도록 했습니다.
    -   **데이터 정합성**: 좌석 예약 로직을 `@Transactional` 어노테이션을 사용하여 트랜잭션 내에서 처리했습니다. 이를 통해 데이터베이스 작업이 중간에 실패할 경우 모든 변경사항이 롤백되어 데이터의 일관성을 보장합니다.
